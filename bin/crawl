#!/usr/bin/env python

import sys
import re
import os
import os.path
import argparse
import logging
import subprocess
import multiprocessing
import shutil
import boto3


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--bucket', metavar='<bucket>', required=True)
    parser.add_argument('--seeds', metavar='<file>', required=True)
    parser.add_argument('--buffer', metavar='<directory>', required=True)
    args = parser.parse_args()

    logging_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(format='crawler: %(levelname)s: %(message)s',
                        level=logging_level)
    boto3.set_stream_logger('boto3.resources', logging.CRITICAL)

    generator = ({
        'ppid': row[0],
        'depth': row[1],
        'seeds': row[2:],
        'bucket': args.bucket,
        'buffer': args.buffer
    } for row in inputFromS3(args.bucket, args.seeds))

    pool = multiprocessing.Pool(300)
    for message in pool.imap_unordered(fetch, generator):
        logging.info(message)
    pool.close()
    pool.join()


def fetch(opts):

    with Content(opts['buffer'], opts['ppid']) as temp:
        temp.fetch(opts['seeds'], opts['depth'])
        temp.upload(opts['bucket'])

    return '{} ... done'.format(opts['ppid'])


def inputFromS3(bucket, seeds):
    try:
        response = boto3.resource('s3').Object(bucket, seeds).get()

        return (line.decode('utf-8').split('\t')
                for line in response.get('Body').read().splitlines())
    except:
        logging.exception("fetch '%s' from bucket '%s' failed",
                          seeds, bucket)
        return (row for row in [])


class Content(object):
    def __init__(self, directory, ppid):
        self.ppid = ppid
        self.directory = directory
        self.name = os.path.join(directory, ppid)
        self.output = os.path.join(self.name, 'output')
        self.seeds = os.path.join(self.name, 'seeds')
        self.content = os.path.join(self.name, 'content')
        os.mkdir(self.name)

    def __enter__(self):
        return self

    def __exit__(self, _type, _value, _traceback):
        if self.name is not None:
            shutil.rmtree(self.name)

    def fetch(self, seeds, depth):
        with open(self.seeds, mode='a', encoding='UTF-8') as seed_handler:
            for seed in seeds:
                seed_handler.write(seed + '\n')
            seed_handler.close()

        exts = {
            '.js', '.css', '.xml', '.atom', '.rss', '.jpeg', '.jpg', '.tif',
            '.gif', '.bmp', '.png', '.svg', '.ttf', '.woff', '.psb', '.psd',
            '.pdf', '.gz', '.bz2', '.zip', '.doc', '.docx', '.xls', '.xslx',
            '.ppt', '.pptx', '.swf', '.flac', '.fla', '.mp3', '.mp4', '.wav',
            '.wmv', '.mov'
        }

        cmd = ['wget', '--recursive', '--level={}'.format(depth),
               '--tries=5', '--dns-timeout=30', '--connect-timeout=5',
               '--read-timeout=5', '--timestamping', '--wait=5',
               '--random-wait', '--no-parent', '--no-verbose',
               '--no-check-certificate', '--input-file', self.seeds,
               '--reject=' + ','.join(exts),
               '--reject=' + ','.join(ext.upper() for ext in exts),
               '--warc-file', os.path.join(self.name, self.ppid),
               '--warc-tempdir', self.content]

        logging.debug('execute %s', cmd)
        ec = subprocess.call(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        logging.info('%s %s finished %s', cmd[0], self.ppid, ec)

    def upload(self, bucket):
        filename = self.ppid + '.warc.gz'
        result_path = os.path.join(self.name, filename)

        if not os.path.exists(result_path):
            return

        with open(result_path, mode='rb') as handle:
            boto3.resource('s3') \
                 .Bucket(bucket) \
                 .put_object(Key=filename,
                             ContentType='application/x-gzip',
                             Body=handle.read())


if __name__ == '__main__':
    sys.exit(main())
