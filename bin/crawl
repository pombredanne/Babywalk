#!/usr/bin/env python

import sys
import os
import os.path
import argparse
import logging
import subprocess
import shutil
import boto3
import pika
import json


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--tempdir', metavar='<directory>', required=True)
    args = parser.parse_args()

    logging_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(format='crawl: %(levelname)s: %(message)s',
                        level=logging_level)
    boto3.set_stream_logger('boto3.resources', logging.CRITICAL)

    input_queue_name = 'crawler-input'
    output_queue_name = 'crawler-output'

    connection = pika.BlockingConnection(pika.ConnectionParameters())

    channel = connection.channel()

    channel.queue_declare(queue=input_queue_name,
                          durable=True,
                          exclusive=False,
                          auto_delete=False)

    channel.queue_declare(queue=output_queue_name,
                          durable=True,
                          exclusive=False,
                          auto_delete=False)

    channel.basic_qos(prefetch_count=1)
    channel.basic_consume(create_callback(args.tempdir, output_queue_name),
                          queue=input_queue_name)

    try:
        channel.start_consuming()
    except KeyboardInterrupt:
        channel.stop_consuming()
    finally:
        connection.close()


def create_callback(tempdir, report_queue_name):

    def callback(ch, method, properties, body):

        logging.debug("received %s", body)
        opts = json.loads(body.decode('utf-8', 'strict'))
        opts.update({'directory': tempdir})

        object_name = Content.get(opts)

        # acknowledge the request
        ch.basic_ack(delivery_tag=method.delivery_tag)
        # report the result
        message = {
            'result': object_name,
            'uid': opts['uid'],
            'seed': opts['seed'],
            'depth': opts['depth']
        }
        ch.basic_publish(exchange='',
                         routing_key=report_queue_name,
                         body=json.dumps(message,
                                         ensure_ascii=False),
                         properties=pika.BasicProperties(
                             content_type='application/json'))

    return callback


class Content(object):
    def __init__(self, directory, uid):
        self.uid = uid
        self.name = os.path.join(directory, uid)
        self.content = os.path.join(self.name, 'content')
        os.mkdir(self.name)

    def __enter__(self):
        return self

    def __exit__(self, _type, _value, _traceback):
        if self.name is not None:
            shutil.rmtree(self.name)

    def fetch(self, seed, depth):
        exts = {
            '.js', '.css', '.xml', '.atom', '.rss', '.jpeg', '.jpg', '.tif',
            '.gif', '.bmp', '.png', '.svg', '.ttf', '.woff', '.psb', '.psd',
            '.pdf', '.gz', '.bz2', '.zip', '.doc', '.docx', '.xls', '.xslx',
            '.ppt', '.pptx', '.swf', '.flac', '.fla', '.mp3', '.mp4', '.wav',
            '.wmv', '.mov'
        }

        cmd = ['wget', '--recursive', '--level={}'.format(depth), '--tries=5',
               '--dns-timeout=30', '--connect-timeout=5', '--read-timeout=5',
               '--timestamping', '--wait=5', '--random-wait', '--no-parent',
               '--no-verbose', '--no-check-certificate',
               '--reject=' + ','.join(exts),
               '--reject=' + ','.join(ext.upper() for ext in exts),
               '--warc-file', os.path.join(self.name, self.uid),
               '--warc-tempdir', self.content, seed]

        logging.debug('execute %s', cmd)
        ec = subprocess.call(cmd,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        logging.info('%s %s finished %s', cmd[0], self.uid, ec)

    def upload(self, bucket):
        filename = self.uid + '.warc.gz'
        result_path = os.path.join(self.name, filename)

        if not os.path.exists(result_path):
            return

        with open(result_path, mode='rb') as handle:
            boto3.resource('s3') \
                 .Bucket(bucket) \
                 .put_object(Key=filename,
                             ContentType='application/x-gzip',
                             Body=handle.read())

        return 's3://{}/{}'.format(bucket, filename)

    @staticmethod
    def get(opts):

        with Content(opts['directory'], opts['uid']) as temp:
            temp.fetch(opts['seed'], opts['depth'])
            return temp.upload(opts['bucket'])


if __name__ == '__main__':
    sys.exit(main())
