#!/usr/bin/env python

import sys
import argparse
import logging
import pika
import json

from libbabywalk import SEED_CRAWLER_QUEUE, SEED_REPORT_QUEUE, create_queue, send_message
from libbabywalk.inputs import rows_from_tsv, filter_ppid_and_seed, group_seeds_by_hostname


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--input',
                        metavar='<file>',
                        dest='seeds',
                        required=True)
    parser.add_argument('--bucket', metavar='<bucket>', required=True)
    parser.add_argument('--depth', metavar='<number>', required=True)
    parser.add_argument('--tag', default='first')
    args = parser.parse_args()

    logging_level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(format='seed: %(levelname)s: %(message)s',
                        level=logging_level)

    connection = pika.BlockingConnection(pika.ConnectionParameters())
    channel = connection.channel()
    create_queue(channel, SEED_CRAWLER_QUEUE)
    create_queue(channel, SEED_REPORT_QUEUE)

    seed_ppid_generator = filter_ppid_and_seed(rows_from_tsv(args.seeds))
    reported_seeds = report_seed(seed_ppid_generator, channel)
    grouped_seeds = group_seeds_by_hostname(reported_seeds)

    for seeds in grouped_seeds:
        send_message(channel, SEED_CRAWLER_QUEUE, {
                                                      'seeds': seeds,
                                                      'depth': args.depth,
                                                      'bucket': args.bucket,
                                                      'tag': args.tag
                                                  })
    connection.close()


def report_seed(iterator, channel):
    for message in iterator:
        send_message(channel, SEED_REPORT_QUEUE, message)
        yield message


if __name__ == '__main__':
    sys.exit(main())
